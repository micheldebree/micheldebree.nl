---
title: "About me"
date: 2019-12-03T17:25:57+01:00
draft: true
---

## Personal guidelines

Rather than being religious about techniques and methodologies, I let the
experience and intuition I have acquired over the years guide my my daily work.
Some guidelines:

- **Purpose**; software should serve a real purpose other than make the coder
  look smart or pay for his/her mortgage
- **Sustainability**; software should be maintainable, scalable, secure and
  adaptable. To both your future self as to other developers. Software is never
  finished, only abandoned.
- **Ownership**; take responsibility for your solution.
- **Minimalism**; leverage existing software because _code is where the bugs
  hide_. Write as little code as possible, _but not less_.
- **Efficiency**; IT resources are expensive, don't overconsume. Measure
  performance, fix the bottlenecks and be very skeptical about premature optimization.
- **Hygiene**; write readable, adaptable code, but don't obsess over it.
  Sometimes duplication makes code more adaptable. Sometimes a
  well-documentedhack is the right thing at the right moment.
- **Criticism**; be your own worse critic. Give and embrace constructive
  criticism.
- **Skeptisism**; don't trust your solution but instead do your best to try and
  break it. Don't assume but verify. To be safe, don't trust anything or anyone
  except Murphy's law.
- **Intrinsic gratification**; get your kick from working solutions and user
  satisfaction, not from ego boosting, job title, politics or perks.
- **Automation over documentation**; code doesn't lie. Documentation often does.
- **Untested features are broken by default**. Fix it before you ship it.

These guidelines can often be conflicting in practice. That is where
experience and common sense comes in to help you make the right choices.


With over 15 years of experience in complex and dynamic IT landscapes, I am
equipped to help you build and run automated solutions in an agile and sustainable way.

It is my job and passion to use this experience to take ownership of the full
technology stack and stakeholders' interests to make sure software works, and -
more importantly - keeps working out there in the real world.

Software is great. It allows us to quickly build fantastic, flexible stuff.
Because of this, the complexity of software also tends to spiral out of control
very rapidly. Complexity is where the bugs hide.

It is my passion to use my experience to be able to identify, communicate and
mitigate the impact of every single change to a software system and make sure it
doesn't only 'work', but

Impact:

- Building it so it works (build, review, test)
- Costs in terms of maintainability (how safe and quick can we change things)
- Costs in terms of risk (what is the risk to existing functionality? might
  things break, become slower, or more instable?)

"The software works" is not enough. It is only the beginning. The real challenge
is to be able to say "It will keep working". Software runs in the real world,
where it has multiple users, limited resources, service level agreements,
multiple stakeholders with different interests and expectations.

It is my job and passion to use this experience to take ownership of the full
technology stack and stakeholders' interests to make sure software works, and -
more importantly - keeps working out there in the real world.
